import{_ as l,c as d,e as r,a as o,d as c,b as i,r as t,o as n}from"./app-CRUSJUWc.js";const a={},p={id:"access-control-allow-credentials",tabindex:"-1"},h={class:"header-anchor",href:"#access-control-allow-credentials"},g={href:"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials",target:"_blank",rel:"noopener noreferrer"},u={href:"https://maomao.ink/index.php/IT/1587.html",target:"_blank",rel:"noopener noreferrer"},C={id:"script-标签的-crossorigin-属性",tabindex:"-1"},m={class:"header-anchor",href:"#script-标签的-crossorigin-属性"},T={href:"https://juejin.cn/post/6969825311361859598",target:"_blank",rel:"noopener noreferrer"};function f(k,e){const s=t("ExternalLinkIcon");return n(),d("div",null,[e[8]||(e[8]=r('<h1 id="跨域" tabindex="-1"><a class="header-anchor" href="#跨域"><span>跨域</span></a></h1><h2 id="跨域概述" tabindex="-1"><a class="header-anchor" href="#跨域概述"><span>跨域概述</span></a></h2><p>当一个资源从与该资源本身所在的服务器不同的 <strong><code>域、协议、端口</code></strong> 请求一个资源时，资源会发起一个跨域 HTTP 请求。出于安全原因，浏览器限制从脚本内发起的跨源 HTTP 请求，XMLHttpRequest 和 Fetch API，只能从加载应用程序的一个域请求 HTTP 资源，除非使用<code>CORS头文件</code>。</p><p><strong><code>浏览器限制</code></strong>：不一定是浏览器限制了发起跨站请求，也可能是跨站请求可以正常发起，但返回结果被浏览器拦截。</p><h2 id="cors-概述" tabindex="-1"><a class="header-anchor" href="#cors-概述"><span>CORS 概述</span></a></h2><p>跨域资源共享标准新增了一组 HTTP 首部字段，<strong>允许服务器声明哪些源站通过浏览器有权限访问哪些资源</strong>。</p><p>另外，规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求），<strong>浏览器必须首先使用 OPTIONS 方法发起一个<code>预检请求</code>（preflight request），从而获知服务器是否允许该跨域请求。</strong></p><p><strong>服务器确认允许之后，才发起实际的HTTP请求</strong>。 在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括 cookie 和 HTTP 认证相关数据）。</p><p>话不多说，直接上图。</p><p><img src="https://user-images.githubusercontent.com/25027560/50205846-accac300-03a4-11e9-8654-2d646d237820.png" alt=""></p><h3 id="简单请求" tabindex="-1"><a class="header-anchor" href="#简单请求"><span>简单请求</span></a></h3><p>不会触发 CORS 预检的请求称为简单请求，满足以下<strong>所有条件</strong>的才会被视为简单请求，基本上日常开发只会关注前面两点。</p><ul><li>使用 <code>GET</code>、<code>POST</code>、<code>HEAD</code> 其中一种方法</li><li>只使用了如下的安全首部字段，不得人为设置其他首部字段 <ul><li><code>Accept</code></li><li><code>Accept-Language</code></li><li><code>Content-Language</code></li><li><code>Content-Type</code> 仅限以下三种 <ul><li><code>text/plain</code></li><li><code>multipart/form-data</code></li><li><code>application/x-www-form-urlencoded</code></li></ul></li><li>HTML 头部 header filed 字段：<code>DPR</code>、<code>Download</code>、<code>Save-Data</code>、<code>Viewport-Width</code>、<code>Width</code></li></ul></li><li>请求中的任意 <code>XMLHttpRequestUpload</code> 对象均没有注册任何事件监听器；<code>XMLHttpRequestUpload</code>对象可以使用 <code>XMLHttpRequest.upload</code> 属性访问</li><li>请求中没有使用 <code>ReadableStream</code> 对象</li></ul><h3 id="预检请求" tabindex="-1"><a class="header-anchor" href="#预检请求"><span>预检请求</span></a></h3><p>需预检的请求要求必须使用 OPTIONS 方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。<code>预检请求</code> 的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响。</p><p>下面的请求会触发预检请求，其实<strong>非简单请求之外的都会触发预检</strong></p><ul><li>使用 <code>PUT</code>、<code>DELETE</code>、<code>CONNECT</code>、<code>OPTIONS</code>、<code>TRACE</code>、<code>PATCH</code> 方法</li><li>人为设置了非规定内的其他首部字段，参考上面简单请求的安全字段集合，还要特别注意 <code>Content-Type</code> 的类型</li><li><code>XMLHttpRequestUpload</code> 对象注册了任何事件监听器</li><li>请求中使用了 <code>ReadableStream</code> 对象</li></ul><h3 id="请求附带身份凭证-cookie" tabindex="-1"><a class="header-anchor" href="#请求附带身份凭证-cookie"><span>请求附带身份凭证 =&gt; cookie</span></a></h3><p>如果发起请求时设置 <code>WithCredentials</code> 标志设置为 <code>true</code>，从而向服务器发送 <code>cookie</code>，但是如果服务器的响应中未携带 <code>Access-Control-Allow-Credentials: true</code>，浏览器将不会把响应内容返回给请求的发送者。</p><p>对于附带身份凭证的请求，服务器不得设置 <code>Access-Control-Allow-Origin</code> 的值为<code>*</code>，必须是某个具体的域名。</p><p>注意，简单 GET 请求不会被预检；如果此类带有身份凭证请求的响应中不包含该字段，这个响应将被忽略掉，并且浏览器也不会将相应内容返回给网页。</p><h2 id="完整请求流程" tabindex="-1"><a class="header-anchor" href="#完整请求流程"><span>完整请求流程</span></a></h2><p><img src="https://user-images.githubusercontent.com/25027560/50205881-c409b080-03a4-11e9-8a57-a2a6d0e1d879.png" alt=""></p><h2 id="cors" tabindex="-1"><a class="header-anchor" href="#cors"><span>CORS</span></a></h2>',24)),o("h3",p,[o("a",h,[o("span",null,[o("a",g,[e[0]||(e[0]=c("Access-Control-Allow-Credentials")),i(s)])])])]),e[9]||(e[9]=r('<p><code>Access-Control-Allow-Credentials</code> 响应头用于在请求要求包含 credentials 时，告知浏览器是否可以将对请求的响应暴露给前端 JS 代码。</p><p>当请求的 credentials 模式为 include 时，浏览器仅在响应标头 <code>Access-Control-Allow-Credentials</code> 的值为 true 的情况下将响应暴露给前端的 JS 代码。</p><p>Credentials 可以是 cookies、authorization headers 或 TLS client certificates。</p><p>当作为预检请求的响应的一部分时，这能表示是否真正的请求可以使用 credentials。<strong>注意简单的 GET 请求没有预检，所以若一个对资源的请求代理 credentials，如果这个响应头没有随资源返回，响应就会被浏览器忽视，不会返回到 web 内容。</strong></p><p><code>Access-Control-Allow-Credentials</code> 标头需要与 <code>XMLHttpRequest.withCredentials</code> 或 Fetch API 的 <code>Request()</code> 构造函数中的 <code>credentials</code> 选项结合使用。Credentials 必须在前后端都被配置（即 <code>Access-Control-Allow-Credentials</code> header 和 XHR 或 Fetch requeset 中都要配置）才能使带 credentials 的 CORS 请求成功。</p><h4 id="tips" tabindex="-1"><a class="header-anchor" href="#tips"><span>tips</span></a></h4>',6)),o("ol",null,[o("li",null,[o("a",u,[e[1]||(e[1]=c("🔗")),i(s)]),e[2]||(e[2]=c(" 如果服务器端开启了 Access-Control-Allow-Credentials 为 true，假设服务器端设置了 Access-Control-Allow-Origin 为 *，意味着将 cookie 开放给了所有网站。如果服务端设置了 ")),e[3]||(e[3]=o("code",null,'"Access-Control-Allow-Origin": "*"',-1)),e[4]||(e[4]=c("，客户端请求时无需再设置 ")),e[5]||(e[5]=o("code",null,"withCredentials: true",-1)),e[6]||(e[6]=c("。"))])]),o("h3",C,[o("a",m,[o("span",null,[o("a",T,[e[7]||(e[7]=c("script 标签的 crossorigin 属性")),i(s)])])])]),e[10]||(e[10]=r('<h4 id="script-标签请求资源" tabindex="-1"><a class="header-anchor" href="#script-标签请求资源"><span>script 标签请求资源</span></a></h4><ol><li>script 标签请求资源的时候，request 是没有 origin 头的。</li><li>script 标签请求跨域资源的时候，内部运行如果报错的话，<code>window.onerror</code> 捕获的时候，内部的 <code>error.message</code> 只能看到 <code>Script error</code>，看不到完整的错误内容。</li></ol><h4 id="script-标签-crossorigin-属性" tabindex="-1"><a class="header-anchor" href="#script-标签-crossorigin-属性"><span>script 标签 crossorigin 属性</span></a></h4><ol><li>设置 <code>crossorigin</code> 属性后，<code>script</code> 标签去请求资源的时候，request 会带上 origin 头，然后会要求服务器进行 cors 校验，跨域的时候如果 response header 没有 <code>Access-Control-Allow-Origin</code> 是不会拿到资源的。cors 验证通过后，拿到的 script 运行内部报错的话，<code>window.onerror</code> 捕获的时候，内部的 <code>error.message</code> 可以看到完整的错误信息。</li><li><code>crossorigin</code> 的属性值分为 <code>anonymous</code> 和 <code>use-credentials</code>。如果设置了 <code>crossorigin</code> 属性，但是属性值不正确的话，默认是 <code>anonymous</code>。</li><li><code>anonymous</code> 代表同域会带上 cookie，跨域则不带上 cookie，相当于 fetch 请求的 <code>credentials: &#39;same-origin&#39;</code>。</li><li><code>use-credentials</code> 跨域也会带上 cookie，相当于 fetch 请求的 <code>credentials: &#39;include&#39;</code>，这种情况下跨域的 response header 需要设置 <code>&#39;Access-Control-Allow-Credentials&#39; = true</code>，否则 cors 失败。</li></ol><h4 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h4><ol><li>设置了 <code>crossorigin</code> 属性就相当于开启了 cors 校验。</li><li>开启 cors 校验之后，跨域的 script 资源在运行出错的时候，<code>window.onerror</code> 可以捕获到完整的错误信息。</li><li><code>crossorigin=use-credentials</code> 可以跨域带上 cookie。</li></ol>',6))])}const A=l(a,[["render",f],["__file","cross-domain.html.vue"]]),b=JSON.parse('{"path":"/blogs/network-browser/cross-domain.html","title":"跨域","lang":"zh-CN","frontmatter":{"title":"跨域","date":"2019-3-22","editLink":false,"tags":["网络与浏览器"],"categories":["前端"]},"headers":[{"level":2,"title":"跨域概述","slug":"跨域概述","link":"#跨域概述","children":[]},{"level":2,"title":"CORS 概述","slug":"cors-概述","link":"#cors-概述","children":[{"level":3,"title":"简单请求","slug":"简单请求","link":"#简单请求","children":[]},{"level":3,"title":"预检请求","slug":"预检请求","link":"#预检请求","children":[]},{"level":3,"title":"请求附带身份凭证 => cookie","slug":"请求附带身份凭证-cookie","link":"#请求附带身份凭证-cookie","children":[]}]},{"level":2,"title":"完整请求流程","slug":"完整请求流程","link":"#完整请求流程","children":[]},{"level":2,"title":"CORS","slug":"cors","link":"#cors","children":[{"level":3,"title":"Access-Control-Allow-Credentials","slug":"access-control-allow-credentials","link":"#access-control-allow-credentials","children":[]},{"level":3,"title":"script 标签的 crossorigin 属性","slug":"script-标签的-crossorigin-属性","link":"#script-标签的-crossorigin-属性","children":[]}]}],"git":{"createdTime":1739535625000,"updatedTime":1739535625000,"contributors":[{"name":"sankigan","email":"sankigan@tencent.com","commits":1}]},"filePathRelative":"blogs/network-browser/cross-domain.md"}');export{A as comp,b as data};
