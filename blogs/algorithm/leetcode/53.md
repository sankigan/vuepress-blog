---
title: LeetCode 「中等」53.最大子数组和
date: 2025-2-17
editLink: false
tags:
  - LeetCode
categories:
  - 算法
---

> [最大子数组和](https://leetcode.cn/problems/maximum-subarray/description/)

## 题目描述

给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

子数组是数组中的一个连续部分。

**示例**

```
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6

输入：nums = [1]
输出：1

输入：nums = [5,4,-1,7,8]
输出：23
```

## 解法

### 暴力法

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function(nums) {
  let ans = Number.NEGATIVE_INFINITY;
  for (let i = 0; i < nums.length; ++i) {
    let rk = i + 1;
    let cur = nums[i];
    let max = cur;
    while (rk < nums.length) {
      cur += nums[rk++];
      max = Math.max(cur, max);
    }
    ans = Math.max(ans, max);
  }
  return ans;
};
```

### 动态规划

遍历一遍给定数组，用 `pre` 存储 **当前数字** 与 **当前数字与之前和** 的最大值，如果当前数字更大，直接从当前数字开始重新计算。并用 `maxAns` 来存储最大的结果。

用 `f(i)` 代表以第 `i` 个数结尾的 **连续子数组的最大和**，那么 `f(i) = max{ f(i−1) + nums[i], nums[i] }`

```js
var maxSubArray = function(nums) {
  let pre = 0, maxAns = nums[0];
  nums.forEach(num => {
    pre = Math.max(pre + num, num);
    maxAns = Math.max(pre, maxAns);
  });
  return maxAns;
};
```
